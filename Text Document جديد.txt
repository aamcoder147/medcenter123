# -*- coding: utf-8 -*-
from flask import (
    Flask, render_template, json, request, redirect, url_for,
    send_from_directory, flash, jsonify, make_response
)
import sqlite3
from flask_login import LoginManager, UserMixin, current_user # Assuming you might use login later
import os
from datetime import datetime, timedelta, date
import uuid
from collections import defaultdict # Helpful for aggregation
import json # Needed for handling JSON in DB
import math # For ceiling function for stars

app = Flask(__name__, static_folder='static')

# Required for flash messages and sessions (if using Flask-Login)
app.secret_key = os.environ.get('FLASK_SECRET_KEY', 'your_default_secret_key_123') # Use environment variable or secure key

# --- Login Manager Setup (Keep if using authentication) ---
# ... (Login Manager code remains the same) ...
login_manager = LoginManager(); login_manager.init_app(app)
class User(UserMixin):
    def __init__(self, id): self.id = id
@login_manager.user_loader
def load_user(user_id):
    if user_id: return User(user_id)
    return None
# --- End Login Manager Setup ---

# --- Database Initialization ---
def get_db():
    db_folder = 'database'; db_path = os.path.join(db_folder, 'bookings.db')
    try:
        conn = sqlite3.connect(db_path); conn.row_factory = sqlite3.Row; return conn
    except sqlite3.Error as e: print(f"DB connection error: {e}"); return None

def init_db():
    db_folder = 'database'; db_path = os.path.join(db_folder, 'bookings.db')
    if not os.path.exists(db_folder): os.makedirs(db_folder)
    conn = None
    try:
        conn = sqlite3.connect(db_path); c = conn.cursor(); print("Initializing database...")
        # --- Create Bookings Table ---
        c.execute('''CREATE TABLE IF NOT EXISTS bookings (id INTEGER PRIMARY KEY AUTOINCREMENT, doctor_id INTEGER NOT NULL, doctor_name TEXT, patient_name TEXT NOT NULL, patient_phone TEXT, booking_date TEXT NOT NULL, booking_time TEXT NOT NULL, notes TEXT, appointment_type TEXT DEFAULT 'Consultation', status TEXT DEFAULT 'Pending', ip_address TEXT, cookie_id TEXT, fingerprint TEXT, user_id INTEGER, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (doctor_id) REFERENCES doctors(id) )''')
        print("Bookings table checked/created.")
        # --- Create Doctors Table ---
        c.execute('''CREATE TABLE IF NOT EXISTS doctors (id INTEGER PRIMARY KEY, name TEXT NOT NULL, availability1shortform TEXT, province TEXT, governorate TEXT, facility_type TEXT, rate REAL, plc TEXT, specialization TEXT, photo TEXT, description TEXT, availability TEXT )''')
        print("Doctors table checked/created.")
        # --- *NEW*: Create Reviews Table ---
        c.execute('''CREATE TABLE IF NOT EXISTS reviews (id INTEGER PRIMARY KEY AUTOINCREMENT, doctor_id INTEGER NOT NULL, reviewer_name TEXT NOT NULL, reviewer_phone TEXT, rating INTEGER NOT NULL CHECK(rating >= 1 AND rating <= 5), comment TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, is_approved INTEGER DEFAULT 1, FOREIGN KEY (doctor_id) REFERENCES doctors(id))''')
        print("Reviews table checked/created.")
        # --- Populate Doctors Table (Only if empty) ---
        # ... (Same doctor data population code as before) ...
        c.execute("SELECT COUNT(*) FROM doctors")
        if c.fetchone()[0] == 0:
             print("Populating Doctors table..."); initial_doctors = [ {"id": 1, "name": "Dr. Aisha Khan", "availability1shortform": "Mon-Thu: 7am-8am, Sat-Sun: 8am-11am", "province": "Bagmati", "governorate": "Kathmandu", "facility_type": "Private Clinic", "rate": 4.5, "plc": "City Clinic", "specialization": "Dermatology", "photo": "/static/doctors/doctor1.jpg", "description": "Expert dermatology care.", "availability": json.dumps({"Monday": ["07:00-07:20", "07:20-07:40", "07:40-08:00"], "Tuesday": ["07:00-07:20", "07:20-07:40", "07:40-08:00"],"Wednesday": ["07:00-07:20", "07:20-07:40", "07:40-08:00"], "Thursday": ["07:00-07:20", "07:20-07:40", "07:40-08:00"], "Friday": ["Unavailable"],"Saturday": ["08:00-08:20", "08:20-08:40", "08:40-09:00", "09:00-09:20", "09:20-09:40", "09:40-10:00", "10:00-10:20", "10:20-10:40", "10:40-11:00"], "Sunday": ["08:00-08:20", "08:20-08:40", "08:40-09:00"]})}, {"id": 2, "name": "Dr. Binod Sharma", "availability1shortform": "Mon-Wed: 7am-8am, Sat: 8am-11am, Sun: 8am-9am", "province": "Gandaki", "governorate": "Kaski", "facility_type": "Hospital", "rate": 4.2, "plc": "Lakeview Hospital", "specialization": "Cardiology", "photo": "/static/doctors/doctor3.jpg", "description": "Heart health specialist.", "availability": json.dumps({"Monday": ["07:00-07:20", "07:20-07:40", "07:40-08:00"], "Tuesday": ["07:00-07:20", "07:20-07:40", "07:40-08:00"], "Wednesday": ["07:00-07:20", "07:20-07:40", "07:40-08:00"], "Thursday": ["Unavailable"], "Friday": ["Unavailable"], "Saturday": ["08:00-08:20", "08:20-08:40", "08:40-09:00", "09:00-09:20", "09:20-09:40", "09:40-10:00", "10:00-10:20", "10:20-10:40", "10:40-11:00"], "Sunday": ["08:00-08:20", "08:20-08:40", "08:40-09:00"]})}, # (Include all other initial doctor data)
            {"id": 11, "name": "Dr. Sofia Anders", "availability1shortform": "Mon, Wed: 9am-11am", "province": "Bagmati", "governorate": "Kathmandu", "facility_type": "Private Clinic", "rate": 4.6, "plc": "City Clinic", "specialization": "General Physician", "photo": "/static/doctors/doctor_female_gp.jpg", "description": "Primary care provider.", "availability": json.dumps({"Monday": ["09:00-09:30", "09:30-10:00", "10:00-10:30", "10:30-11:00"], "Tuesday": ["Unavailable"], "Wednesday": ["09:00-09:30", "09:30-10:00", "10:00-10:30", "10:30-11:00"], "Thursday": ["Unavailable"], "Friday": ["Unavailable"], "Saturday": ["Unavailable"], "Sunday": ["Unavailable"]})}]
             c.executemany('INSERT INTO doctors (id, name, availability1shortform, province, governorate, facility_type, rate, plc, specialization, photo, description, availability) VALUES (:id, :name, :availability1shortform, :province, :governorate, :facility_type, :rate, :plc, :specialization, :photo, :description, :availability)', initial_doctors)
             print(f"Inserted {len(initial_doctors)} doctors.")
        else: print("Doctors table populated.")
        # --- Add Indexes ---
        c.execute("CREATE INDEX IF NOT EXISTS idx_booking_doctor_date ON bookings(doctor_id, booking_date)")
        c.execute("CREATE INDEX IF NOT EXISTS idx_reviews_doctor_id ON reviews(doctor_id)")
        print("Indexes checked/created.")
        conn.commit()
        print("Database initialization complete.")
    except sqlite3.Error as e: print(f"DB init error: {e}"); conn.rollback()
    finally: conn.close()

# --- Load doctors data FROM DATABASE (Modified to include ratings) ---
def load_doctors_from_db():
    """Fetches doctors, parses availability, and calculates average rating."""
    conn = get_db()
    if not conn: print("CRITICAL: DB fail load_doctors_from_db."); return []
    doctors_list = []
    try:
        c = conn.cursor(); c.execute("SELECT * FROM doctors ORDER BY name ASC"); doctors_rows = c.fetchall()
        if not doctors_rows: return []
        for row in doctors_rows:
            try:
                doctor_dict = dict(row); doctor_dict['availability'] = json.loads(doctor_dict.get('availability', '{}') or '{}'); doctor_dict['average_rating'] = 0.0; doctor_dict['review_count'] = 0; doctors_list.append(doctor_dict)
            except Exception as json_err:
                print("Warn: Parse error doc {}: {}".format(row['id'], json_err))
                doctor_dict = dict(row)
                doctor_dict['availability'] = {}
                doctor_dict['average_rating'] = 0.0
                doctor_dict['review_count'] = 0
                doctors_list.append(doctor_dict) # Add with defaults
        # Calculate ratings
        doctor_map = {doc['id']: doc for doc in doctors_list}
        c.execute('SELECT doctor_id, AVG(rating) as avg_r, COUNT(id) as count_r FROM reviews WHERE is_approved = 1 GROUP BY doctor_id')
        rating_rows = c.fetchall()
        for rating_row in rating_rows:
            doc_id = rating_row['doctor_id']
            if doc_id in doctor_map:
                doctor_map[doc_id]['average_rating'] = round(rating_row['avg_r'], 1) if rating_row['avg_r'] is not None else 0.0; doctor_map[doc_id]['review_count'] = rating_row['count_r']
        doctors_list = list(doctor_map.values())
    except sqlite3.Error as e: print(f"Error loading doctors: {e}"); return []
    finally: conn.close()
    print(f"Loaded {len(doctors_list)} doctors with rating info."); return doctors_list

# --- Initialize DB and Load Data ---
init_db()
doctors_data = load_doctors_from_db()
if not doctors_data: print("CRITICAL WARNING: Failed to load doctor data.")

# --- Helper Function for Templates ---
@app.context_processor
def utility_processor():
    def get_stars(rating):
        if rating is None or not isinstance(rating, (int, float)) or rating < 0: return ['far fa-star'] * 5
        full = math.floor(rating); half = (rating - full) >= 0.5; empty = 5 - full - (1 if half else 0)
        stars = ['fas fa-star'] * full + (['fas fa-star-half-alt'] if half else []) + ['far fa-star'] * empty
        return stars
    return dict(get_stars=get_stars)


# --- Routes ---
@app.route('/')
def home(): # Uses global doctors_data (with ratings)
    # ... (Stat and filter loading logic remains the same) ...
    stats = { 'doctor_count': len(doctors_data), 'specialty_count': 0, 'total_bookings': 0 }; specialties = []; governorates = []; facility_types = []; plcs = []
    if doctors_data:
         unique_specs = sorted(list({d['specialization'] for d in doctors_data if d.get('specialization')})); unique_govs = sorted(list({d['governorate'] for d in doctors_data if d.get('governorate')})); unique_fac_types = sorted(list({d['facility_type'] for d in doctors_data if d.get('facility_type')})); unique_plcs = sorted(list({d['plc'] for d in doctors_data if d.get('plc')})); stats['specialty_count'] = len(unique_specs); specialties = unique_specs; governorates = unique_govs; facility_types = unique_fac_types; plcs = unique_plcs
    conn = get_db();
    if conn:
        c = conn.cursor();
        try:
            c.execute("SELECT COUNT(*) FROM bookings WHERE status != 'Cancelled'"); active_count = c.fetchone(); stats['total_active_bookings'] = active_count[0] if active_count else 0
            c.execute("SELECT COUNT(*) FROM bookings"); all_count = c.fetchone(); stats['total_bookings'] = all_count[0] if all_count else 0
            c.execute("SELECT DISTINCT specialization FROM doctors WHERE specialization IS NOT NULL AND specialization != '' ORDER BY specialization ASC"); specialties = [row['specialization'] for row in c.fetchall()] or specialties
            c.execute("SELECT DISTINCT governorate FROM doctors WHERE governorate IS NOT NULL AND governorate != '' ORDER BY governorate ASC"); governorates = [row['governorate'] for row in c.fetchall()] or governorates
            c.execute("SELECT DISTINCT facility_type FROM doctors WHERE facility_type IS NOT NULL AND facility_type != '' ORDER BY facility_type ASC"); facility_types = [row['facility_type'] for row in c.fetchall()] or facility_types
            c.execute("SELECT DISTINCT plc FROM doctors WHERE plc IS NOT NULL AND plc != '' ORDER BY plc ASC"); plcs = [row['plc'] for row in c.fetchall()] or plcs
        except sqlite3.Error as e: print(f"Warn: DB err home: {e}")
        finally: conn.close()
    else: print("Warn: DB conn fail home."); flash('Stats/filters may be outdated.', 'info')
    return render_template('index.html', doctors=doctors_data, stats=stats, specialties=specialties, governorates=governorates, facility_types=facility_types, plcs=plcs)


@app.route('/booking/<int:doctor_id>')
def booking_page(doctor_id):
    try:
        doctor = next((d for d in doctors_data if d['id'] == doctor_id), None)
        if not doctor: flash('Doctor not found.', 'error'); return redirect(url_for('home'))
        reviews = []; conn = get_db()
        if conn:
            c = conn.cursor();
            try: c.execute("SELECT reviewer_name, rating, comment, created_at FROM reviews WHERE doctor_id = ? AND is_approved = 1 ORDER BY created_at DESC LIMIT 10", (doctor_id,)); reviews = [dict(row) for row in c.fetchall()]
            except sqlite3.Error as e: print(f"Error fetch reviews doc {doctor_id}: {e}")
            finally: conn.close()
        else: print(f"Warn: DB fail fetch reviews doc {doctor_id}.")
        today_str = date.today().strftime('%Y-%m-%d'); doctor_availability_schedule = json.dumps(doctor.get('availability', {}))
        response = make_response(render_template('booking.html', doctor=doctor, doctor_id=doctor_id, today=today_str, doctor_availability_schedule=doctor_availability_schedule, reviews=reviews))
        if not request.cookies.get('device_id'): device_id = str(uuid.uuid4()); response.set_cookie('device_id', device_id, max_age=30*24*60*60, httponly=True, samesite='Lax')
        return response
    except Exception as e: print(f"Error booking_page {doctor_id}: {e}"); flash('Error loading booking page.', 'error'); return redirect(url_for('home'))


# --- Submit Review Route (Updated with Booking Check) ---
@app.route('/submit-review', methods=['POST'])
def submit_review():
    doctor_id_str = request.form.get('doctor_id')
    reviewer_name = request.form.get('reviewer_name', '').strip()
    reviewer_phone = request.form.get('reviewer_phone', '').strip()
    rating_str = request.form.get('rating')
    comment = request.form.get('comment', '').strip()

    # Initial Validation
    errors = []
    if not doctor_id_str or not doctor_id_str.isdigit():
        errors.append('Invalid Doctor ID.')
        doctor_id = None
    else:
        doctor_id = int(doctor_id_str)
    if not reviewer_name: errors.append('Your name is required for the review.')
    # Use phone number also for linking review to potential patient
    if not reviewer_phone: errors.append('Your phone number is required for the review.')
    if not rating_str or not rating_str.isdigit() or not (1 <= int(rating_str) <= 5): errors.append('Please select a rating (1-5 stars).')

    if errors:
        for error in errors: flash(f'⛔ {error}', 'error')
        # Try redirecting back, even if doctor_id was invalid
        return redirect(request.referrer or url_for('home')) # Fallback to home

    # Proceed if initial validation passes
    conn = None
    try:
        conn = get_db()
        if not conn:
            flash('⛔ Database error. Could not save review.', 'error')
            return redirect(url_for('booking_page', doctor_id=doctor_id)) # Use validated doctor_id
        c = conn.cursor()

        # *** NEW BOOKING CHECK ***
        # Check if name OR phone exists in bookings for this doctor
        c.execute('''SELECT 1 FROM bookings
                     WHERE doctor_id = ? AND (LOWER(patient_name) = LOWER(?) OR patient_phone = ?)
                     LIMIT 1''',
                  (doctor_id, reviewer_name, reviewer_phone))
        booking_found = c.fetchone()

        if not booking_found:
            flash('⛔ Only patients who have booked with this doctor can leave a review. Ensure your name or phone number matches a past booking.', 'error')
            conn.close()
            return redirect(url_for('booking_page', doctor_id=doctor_id))
        # *** END NEW BOOKING CHECK ***


        # Existing Check: Has this name/phone recently reviewed this doctor? (Prevent spam)
        c.execute('''SELECT 1 FROM reviews
                     WHERE doctor_id = ? AND LOWER(reviewer_name) = LOWER(?) AND reviewer_phone = ?
                     AND created_at >= date('now', '-1 day') LIMIT 1''',
                  (doctor_id, reviewer_name.lower(), reviewer_phone))
        if c.fetchone():
            flash('ℹ️ You seem to have submitted a review for this doctor recently. Please wait before submitting another.', 'info')
            conn.close()
            return redirect(url_for('booking_page', doctor_id=doctor_id))

        # Insert the new review
        c.execute('''INSERT INTO reviews (doctor_id, reviewer_name, reviewer_phone, rating, comment)
                     VALUES (?, ?, ?, ?, ?)''',
                  (doctor_id, reviewer_name, reviewer_phone, int(rating_str), comment))
        conn.commit()

        flash('✅ Thank you! Your review has been submitted.', 'success')
        # --- Refresh global doctor data after adding review ---
        global doctors_data
        doctors_data = load_doctors_from_db() # Reload ALL doctor data with updated ratings
        print(f"Review added for doctor {doctor_id}. Global doctors_data refreshed.")

    except sqlite3.Error as e:
        print(f"Database error submitting review for doctor {doctor_id}: {e}"); flash('⛔ Database error submitting review.', 'error'); conn.rollback()
    except Exception as e:
        print(f"Unexpected error submitting review: {e}"); flash('⛔ Unexpected error submitting review.', 'error'); conn.rollback()
    finally:
        if conn: conn.close()

    return redirect(url_for('booking_page', doctor_id=doctor_id))
# --- END Updated Route ---


# ... (Other routes like /center/, /get-nearest, /get-slots, /confirm-booking, /confirmation, /get-doctor-availability, /delete-booking, login routes, dashboards, /update-notes, /mark-complete remain unchanged conceptually, relying on the loaded doctors_data which includes rating info) ...
@app.route('/center/<path:plc_name>')
def center_details(plc_name): # Uses updated doctors_data
    if not plc_name: flash('No clinic name.', 'error'); return redirect(url_for('home'))
    plc_doctors = [doc for doc in doctors_data if doc.get('plc') == plc_name]
    if not plc_doctors: flash(f'Details not found for "{plc_name}".', 'error'); return redirect(url_for('home'))
    first_doc = plc_doctors[0]
    plc_info = {'name': plc_name, 'facility_type': first_doc.get('facility_type', 'N/A'), 'locations': sorted(list({(d.get('province', 'N/A'), d.get('governorate', 'N/A')) for d in plc_doctors if d.get('province') or d.get('governorate')}))}
    plc_slug = plc_name.lower().replace(' ', '_'); plc_info['photo_path_jpg'] = f'/static/plc_photos/{plc_slug}.jpg'
    return render_template('center_details.html', plc=plc_info, doctors=plc_doctors)

@app.route('/get-nearest-available/<int:doctor_id>')
def get_nearest_available(doctor_id): # No changes needed here
    # ... (Code as before) ...
    conn = None
    doctor = next((d for d in doctors_data if d['id'] == doctor_id), None)
    if not doctor:
        return jsonify({'success': False, 'message': 'Doctor not found'}), 404
    try:
        doctor_availability = doctor.get('availability', {})
        if not doctor_availability:
            return jsonify({'success': False, 'message': 'Schedule unavailable.'}), 404
        today_date = date.today()
        conn = get_db()
        if not conn:
            return jsonify({'success': False, 'message': 'DB error.'}), 500
        c = conn.cursor()
        for i in range(90):
            current_check_date = today_date + timedelta(days=i)
            date_str = current_check_date.strftime('%Y-%m-%d')
            day_name = current_check_date.strftime('%A')
            general_slots_raw = doctor_availability.get(day_name, [])
            general_slots = sorted([slot for slot in general_slots_raw if isinstance(slot, str) and slot.strip() and slot.lower() != "unavailable"])
            if not general_slots:
                continue
            c.execute("SELECT booking_time FROM bookings WHERE doctor_id = ? AND booking_date = ? AND status != 'Cancelled'", 
                      (doctor_id, date_str))
            booked_times = {row['booking_time'] for row in c.fetchall()}
            available_slots = [slot for slot in general_slots if slot not in booked_times]
            if available_slots:
                return jsonify({'success': True, 'date': date_str, 'time': available_slots[0]})
        return jsonify({'success': False, 'message': 'No slots nearby.'}), 404
    except sqlite3.Error as db_err:
        print(f"DB Error (Nearest): {db_err}")
        return jsonify({'success': False, 'message': 'DB error.'}), 500
    except Exception as e:
        print(f"Error (Nearest): {e}")
        return jsonify({'success': False, 'message': 'Internal error.'}), 500
    finally:
        if conn:
            conn.close()

@app.route('/get-available-slots/<int:doctor_id>/<string:date_str>')
def get_available_slots(doctor_id, date_str):
    conn = None
    try:
        booking_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        day_name = booking_date.strftime('%A')
        doctor = next((d for d in doctors_data if d['id'] == doctor_id), None)
        if not doctor:
            return jsonify({'error': 'Doctor not found'}), 404
        doctor_availability = doctor.get('availability', {})
        if not doctor_availability:
            return jsonify([])
        general_slots_raw = doctor_availability.get(day_name, [])
        general_slots = sorted([slot for slot in general_slots_raw if isinstance(slot, str) and slot.strip() and slot.lower() != "unavailable"])
        if not general_slots:
            return jsonify([])
        conn = get_db()
        if not conn:
            return jsonify({'error': 'DB conn error'}), 500
        booked_times = set()
        try:
            c = conn.cursor()
            c.execute("SELECT booking_time FROM bookings WHERE doctor_id = ? AND booking_date = ? AND status != 'Cancelled'", (doctor_id, date_str))
            booked_times = {row['booking_time'] for row in c.fetchall()}
        except sqlite3.Error as e:
            print(f"DB err fetch booked: {e}")
        finally:
            conn.close()
        available_slots = [slot for slot in general_slots if slot not in booked_times]
        return jsonify(available_slots)
    except ValueError:
        return jsonify({'error': 'Invalid date.'}), 400
    except Exception as e:
        print(f"Error (Slots): {e}")
        return jsonify({'error': 'Internal error.'}), 500


@app.route('/confirm-booking', methods=['POST'])
def confirm_booking(): # No changes needed here
    # ... (Code as before) ...
    doctor_id_str=request.form.get('doctor_id'); doctor_name=request.form.get('doctor_name'); patient_name=request.form.get('patient_name'); patient_phone=request.form.get('patient_phone'); booking_date=request.form.get('booking_date'); booking_time=request.form.get('booking_time'); notes=request.form.get('notes','').strip();
    if not all([doctor_id_str, doctor_name, patient_name, patient_phone, booking_date, booking_time]): flash('Missing info.', 'error'); return redirect(request.referrer or url_for('home'));
    try: doctor_id = int(doctor_id_str);
    except ValueError: flash('Invalid doc ID.', 'error'); return redirect(url_for('home'));
    doctor=next((d for d in doctors_data if d['id']==doctor_id),None);
    if not doctor: flash(f'Doc ID {doctor_id} not found.','error'); return redirect(url_for('home'));
    try:
        booking_date_obj = datetime.strptime(booking_date, '%Y-%m-%d').date()
        if booking_date_obj < date.today():
            flash('Cannot book past date.', 'error')
            return redirect(url_for('booking_page', doctor_id=doctor_id))
        selected_day_name = booking_date_obj.strftime('%A')
    except ValueError:
        flash('Invalid date format.', 'error')
        return redirect(url_for('booking_page', doctor_id=doctor_id))
    conn = get_db()
    if not conn:
        flash('DB err. Try again.', 'error')
        return redirect(url_for('booking_page', doctor_id=doctor_id))
    c = conn.cursor()
    booking_id = None
    try:
        doctor_schedule = doctor.get('availability', {})
        day_schedule = doctor_schedule.get(selected_day_name, [])
        general_slots = [s for s in day_schedule if isinstance(s, str) and s.strip() and s.lower() != 'unavailable']
        if booking_time not in general_slots:
            flash('Slot unavailable.', 'error')
            conn.close()
            return redirect(url_for('booking_page', doctor_id=doctor_id))
        
        c.execute(
            "SELECT 1 FROM bookings WHERE doctor_id = ? AND booking_date = ? AND booking_time = ? AND status != 'Cancelled' LIMIT 1",
            (doctor_id, booking_date, booking_time)
        )
        if c.fetchone():
            flash('Slot just booked.', 'error')
            conn.close()
            return redirect(url_for('booking_page', doctor_id=doctor_id))
        
        c.execute(
            "SELECT 1 FROM bookings WHERE (LOWER(patient_name) = LOWER(?) OR patient_phone = ?) AND booking_date = ? AND status != 'Cancelled' LIMIT 1",
            (patient_name.lower(), patient_phone, booking_date)
        )
        if c.fetchone():
            flash('Booking exists this date.', 'error')
            conn.close()
            return redirect(url_for('booking_page', doctor_id=doctor_id))
        
        c.execute(
            "INSERT INTO bookings (doctor_id, doctor_name, patient_name, patient_phone, booking_date, booking_time, notes, status) VALUES (?, ?, ?, ?, ?, ?, ?, 'Pending')",
            (doctor_id, doctor_name, patient_name, patient_phone, booking_date, booking_time, notes)
        )
        conn.commit()
        booking_id = c.lastrowid
    except sqlite3.Error as e: print(f"DB Err(Confirm): {e}");flash('DB error confirm.','error'); conn.rollback(); return redirect(url_for('booking_page', doctor_id=doctor_id));
    except Exception as e: print(f"Err(Confirm): {e}");flash('Unexpected error.','error'); conn.rollback(); return redirect(url_for('booking_page', doctor_id=doctor_id));
    finally: conn.close();
    if booking_id: flash('Booking confirmed!','success'); return redirect(url_for('confirmation',booking_id=booking_id,doctor_name=doctor_name,patient_name=patient_name,booking_date=booking_date,booking_time=booking_time));
    else: flash('Booking failed.','error'); return redirect(url_for('booking_page', doctor_id=doctor_id));

@app.route('/confirmation')
def confirmation(): # No changes needed here
    # ... (Code as before) ...
    booking_id = request.args.get('booking_id')
    doctor_name = request.args.get('doctor_name')
    patient_name = request.args.get('patient_name')
    booking_date = request.args.get('booking_date')
    booking_time = request.args.get('booking_time')
    if not all([booking_id, doctor_name, patient_name, booking_date, booking_time]):
        flash('Invalid link.', 'error')
        return redirect(url_for('home'))
    return render_template('confirmation.html', booking_id=booking_id, doctor_name=doctor_name, patient_name=patient_name, booking_date=booking_date, booking_time=booking_time)

@app.route('/get-doctor-availability/<int:doctor_id>')
def get_doctor_availability(doctor_id): # No changes needed here
    # ... (Code as before) ...
    try:
        doctor = next((d for d in doctors_data if d['id'] == doctor_id), None)
        if not doctor:
            return jsonify({'error': 'Doc not found'}), 404
        doctor_schedule = doctor.get('availability', {})
        if not doctor_schedule:
            return jsonify({})
        availability_data = defaultdict(list)
        today_dt = date.today()
        end_date = today_dt + timedelta(days=120)
        current_date_loop = today_dt
        while current_date_loop <= end_date:
            day_name = current_date_loop.strftime('%A')
            general_slots_raw = doctor_schedule.get(day_name, [])
            has_general_slots = any(isinstance(slot, str) and slot.strip() and slot.lower() != "unavailable" for slot in general_slots_raw)
            if has_general_slots:
                month_str = current_date_loop.strftime('%Y-%m')
                day_num = current_date_loop.day
                availability_data[month_str].append(day_num)
            current_date_loop += timedelta(days=1)
        return jsonify(dict(availability_data))
    except Exception as e:
        print(f"Err(DocAvail): {e}")
        return jsonify({'error': 'Internal error.'}), 500

@app.route('/delete-booking/<int:booking_id>', methods=['POST'])
def delete_booking(booking_id): # No changes needed here
    # ... (Code as before) ...
    conn=None; 
    try:
        conn = get_db()
        if not conn:
            flash('DB error.', 'error')
            return redirect(request.referrer or url_for('home'))
        c = conn.cursor()
        c.execute("UPDATE bookings SET status='Cancelled' WHERE id=? AND status='Pending'", (booking_id,))
        conn.commit()
        if c.rowcount > 0:
            flash('Booking cancelled.', 'success')
        else:
            c.execute('SELECT status FROM bookings WHERE id=?', (booking_id,))
            result = c.fetchone()
            flash('Could not cancel (state changed/not found).', 'info')
    except sqlite3.Error as e: print(f"DB Err(Delete): {e}"); flash('DB error cancel.','error'); conn.rollback();
    except Exception as e: print(f"Err(Delete): {e}"); flash('Unexpected error.','error'); conn.rollback();
    finally: conn.close();
    source=request.form.get('source','home'); patient_identifier=request.form.get('patient_identifier'); doctor_id=request.form.get('doctor_id');
    if source=='patient_dashboard' and patient_identifier: return redirect(url_for('patient_dashboard', patient_identifier=patient_identifier));
    elif source=='doctor_dashboard' and doctor_id: 
       try: return redirect(url_for('doctor_dashboard', doctor_id=int(doctor_id))); 
       except: return redirect(url_for('doctor_login'));
    else: return redirect(request.referrer or url_for('home'));

@app.route('/doctor-login', methods=['GET', 'POST'])
def doctor_login(): # No changes needed here
    # ... (Code as before) ...
    if request.method=='POST': doctor_name=request.form.get('doctorName','').strip(); doctor_id_str=request.form.get('doctorId','').strip();
    if not doctor_name or not doctor_id_str: flash('Enter Name/ID.','error'); return redirect(url_for('doctor_login')); 
    if not doctor_id_str.isdigit(): flash('ID must be num.','error'); return redirect(url_for('doctor_login')); doctor_id=int(doctor_id_str); doctor=next((d for d in doctors_data if d['id']==doctor_id and d['name']==doctor_name),None); 
    if doctor: flash(f'Welcome, {doctor_name}!','success'); return redirect(url_for('doctor_dashboard', doctor_id=doctor_id)); 
    else: flash('Invalid login.','error'); return redirect(url_for('doctor_login'));
    return render_template('doctor_login.html');

@app.route('/doctor-dashboard/<int:doctor_id>')
def doctor_dashboard(doctor_id): # Uses updated doctors_data
    doctor=next((d for d in doctors_data if d['id']==doctor_id), None)
    if not doctor:
        flash("Doctor not found.", "error")
        return redirect(url_for('doctor_login'))

    conn=None
    bookings_rows=[]
    stats=defaultdict(int)
    appointments_per_day_data=defaultdict(int)
    unique_patients_set=set()

    try:
        conn=get_db()
        if not conn:
            flash('DB error.','error')
            return render_template('doctor_dashboard.html', doctor=doctor, doctor_id=doctor_id, bookings_by_month={}, stats={}, chart_config_daily={})

        c=conn.cursor()
        c.execute("SELECT id, doctor_id, doctor_name, patient_name, patient_phone, booking_date, booking_time, notes, status FROM bookings WHERE doctor_id = ? AND status != 'Cancelled' ORDER BY booking_date DESC, booking_time DESC",(doctor_id,))
        bookings_rows=c.fetchall()

        today_date=date.today()
        today_str=today_date.strftime('%Y-%m-%d')
        one_week_later=today_date+timedelta(days=7)
        current_month_str=today_date.strftime('%Y-%m')

        for booking_row in bookings_rows:
            try:
                booking_dict=dict(booking_row)
                booking_date_str_loop=booking_dict['booking_date']
                booking_status=booking_dict['status']
                booking_date_obj=datetime.strptime(booking_date_str_loop,'%Y-%m-%d').date()

                if booking_status=='Pending' and booking_date_obj>=today_date:
                    stats['pending_count']+=1
                if booking_date_str_loop==today_str:
                    stats['today_count']+=1
                if today_date<=booking_date_obj<one_week_later:
                    stats['week_count']+=1
                appointments_per_day_data[booking_date_str_loop]+=1

                if booking_date_str_loop.startswith(current_month_str):
                    patient_identifier=booking_dict.get('patient_name')or booking_dict.get('patient_phone')
                    if patient_identifier:
                        unique_patients_set.add(patient_identifier)
                if booking_status=='Completed':
                    stats['completed_total_count']+=1
            except Exception as e:
                print(f"Warn(Stats): {booking_dict} - Error:{e}")

        stats['unique_patients_this_month']=len(unique_patients_set)
        stats['total_bookings_listed']=len(bookings_rows)

    except sqlite3.Error as e:
        print(f"Error(DocDash): {e}")
        flash('DB error loading.','error')

    finally:
        if conn:
            conn.close()

    chart_labels_daily=[]
    chart_data_daily=[]
    today_date=date.today()
    for i in range(7):
        d=today_date+timedelta(days=i)
        d_str=d.strftime('%Y-%m-%d')
        chart_labels_daily.append(d.strftime('%a,%b %d'))
        chart_data_daily.append(appointments_per_day_data[d_str])

    bookings_by_month=defaultdict(lambda:defaultdict(list))
    for booking_row in bookings_rows:
        try:
            booking_dict=dict(booking_row)
            booking_date_dt=datetime.strptime(booking_dict['booking_date'],'%Y-%m-%d')
            month_year=booking_date_dt.strftime('%B %Y')
            day_str=booking_dict['booking_date']
            bookings_by_month[month_year][day_str].append(booking_dict)
        except Exception as e:
            print(f"Warn(Group): {booking_dict}-Err:{e}")

    final_bookings_by_month={my: dict(days) for my, days in bookings_by_month.items()}

    return render_template('doctor_dashboard.html',doctor=doctor,doctor_id=doctor_id,bookings_by_month=final_bookings_by_month,stats=dict(stats),chart_config_daily={'labels':chart_labels_daily,'data':chart_data_daily})
@app.route('/update-all-notes', methods=['POST'])
def update_all_notes(): # No changes needed here
    # ... (Code as before) ...
    if not request.is_json: return jsonify({'success':False,'message':'Need JSON.'}),400; data=request.get_json(); updates=data.get('updates',[]); 
    if not isinstance(updates,list): return jsonify({'success':False,'message':'Updates must be list.'}),400; conn=None; updated_count=0;
    try:
        conn = get_db()
        if not conn:
            return jsonify({'success': False, 'message': 'DB error.'}), 500
        c = conn.cursor()
        for update in updates:
            booking_id = update.get('bookingId')
            notes = update.get('notes')
            if isinstance(booking_id, (int, str)) and str(booking_id).isdigit() and isinstance(notes, str):
                try:
                    c.execute("UPDATE bookings SET notes=? WHERE id=?", (notes.strip(), int(booking_id)))
                    if c.rowcount > 0:
                        updated_count += 1
                except sqlite3.Error as e:
                    print(f"Warn(NoteUpd{booking_id}):{e}")
            else:
                print(f"Warn(SkipUpd):{update}")
        conn.commit()
        print(f"Notes:{updated_count}/{len(updates)} succ.")
        msg_verb = 'note' if updated_count == 1 else 'notes'
        failed_count = len(updates) - updated_count
        msg = f'{updated_count}{msg_verb} updated.'
        if failed_count > 0:
            msg += f'{failed_count} failed.'
        flash(msg, 'success' if failed_count == 0 else 'warning')
        return jsonify({'success': True, 'message': msg})
    except sqlite3.Error as db_err: print(f"DB Err(Notes):{db_err}"); conn.rollback(); return jsonify({'success':False,'message':f'DB error:{db_err}'}),500;
    except Exception as e: print(f"Err(Notes):{e}"); conn.rollback(); return jsonify({'success':False,'message':f'Internal err:{e}'}),500;
    finally: conn.close();

@app.route('/mark-complete/<int:booking_id>', methods=['POST'])
def mark_complete(booking_id): # No changes needed here
    # ... (Code as before) ...
    conn=None
    try:
        conn=get_db()
        if not conn:
            return jsonify({'success': False, 'message': 'DB error.'}), 500
        c=conn.cursor()
        c.execute("UPDATE bookings SET status='Completed' WHERE id=? AND status='Pending'",(booking_id,))
        conn.commit()

        if c.rowcount>0:
            print(f"Completed booking {booking_id}.")
            return jsonify({'success': True, 'message': 'Booking completed.'})
        else:
            c.execute("SELECT status FROM bookings WHERE id=?",(booking_id,))
            result=c.fetchone()
            msg='Not found.' if not result else f'Status "{result[0]}".' # Access status by index
            print(f"Failed complete {booking_id}:{msg}")
            return jsonify({'success': False, 'message': msg}), 400

    except sqlite3.Error as db_err:
        print(f"DB Err(Complete):{db_err}")
        if conn: conn.rollback() # Rollback only if connection exists
        return jsonify({'success': False, 'message': f'DB err:{db_err}'}), 500
    except Exception as e:
        print(f"Err(Complete):{e}")
        if conn: conn.rollback() # Rollback only if connection exists
        return jsonify({'success': False, 'message': f'Internal err:{e}'}), 500
    finally:
        if conn: conn.close() # Close only if connection exists

@app.route('/patient-login', methods=['GET', 'POST'])
def patient_login(): # No changes needed here
    # ... (Code as before) ...
    if request.method == 'POST':
        patient_identifier = request.form.get('patientIdentifier', '').strip()
        if not patient_identifier:
            flash('Enter Name/Phone.', 'error')
            return redirect(url_for('patient_login'))
        booking_exists = False
        conn = None
        try:
            conn = get_db()
            if not conn:
                flash('DB error.', 'error')
                return redirect(url_for('patient_login'))
            c = conn.cursor()
            c.execute("SELECT 1 FROM bookings WHERE (LOWER(patient_name)=LOWER(?) OR patient_phone=?) AND status != 'Cancelled' LIMIT 1",
                      (patient_identifier, patient_identifier))
            booking_exists = c.fetchone() is not None
        except sqlite3.Error as e:
            print(f"DB Err(PatLogin):{e}")
            flash('DB error check.', 'error')
            return redirect(url_for('patient_login'))
        finally:
            if conn:
                conn.close()
        if booking_exists:
            return redirect(url_for('patient_dashboard', patient_identifier=patient_identifier))
        else:
            flash('No active bookings found.', 'error')
            return redirect(url_for('patient_login'))
    return render_template('patient_login.html')

@app.route('/patient-dashboard/<path:patient_identifier>')
def patient_dashboard(patient_identifier): # No changes needed here
    # ... (Code as before) ...
    if not patient_identifier:
        flash('Missing ID.', 'error')
        return redirect(url_for('patient_login'))
    conn = None
    bookings_rows = []
    try:
        conn = get_db()
        if not conn:
            flash('DB error.', 'error')
            return render_template('patient_dashboard.html', bookings=[], patient_identifier=patient_identifier, error=True)
        c = conn.cursor()
        c.execute("SELECT id,doctor_id,doctor_name,patient_name,patient_phone,booking_date,booking_time,status,notes FROM bookings WHERE (LOWER(patient_name)=LOWER(?) OR patient_phone=?) AND status != 'Cancelled' ORDER BY booking_date DESC, booking_time DESC",
                  (patient_identifier, patient_identifier))
        bookings_rows = c.fetchall()
    except sqlite3.Error as e:
        print("DB Err(PatDash):{}".format(e))
        flash('DB error load.', 'error')
    finally:
        if conn:
            conn.close()
    processed_bookings = []
    current_dt_obj = datetime.now()
    for row in bookings_rows:
        booking_dict = dict(row)
        is_deletable = False
        if booking_dict.get('status') == 'Pending':
            try:
                time_part = booking_dict.get('booking_time', '').split('-')[0].strip()
                full_datetime_str = f"{booking_dict.get('booking_date')} {time_part}"
                booking_dt_obj = None
                for fmt in ["%Y-%m-%d %H:%M", "%Y-%m-%d %I:%M%p", "%Y-%m-%d %I:%M %p"]:
                    try:
                        booking_dt_obj = datetime.strptime(full_datetime_str, fmt)
                        break
                    except ValueError:
                        continue
                if booking_dt_obj and booking_dt_obj > current_dt_obj:
                    is_deletable = True
            except Exception as e:
                print(f"Warn(ParseTime {booking_dict.get('id')}): {e}")
        booking_dict['is_deletable'] = is_deletable
        processed_bookings.append(booking_dict)
    return render_template('patient_dashboard.html',bookings=processed_bookings,patient_identifier=patient_identifier);

# --- Run Application ---
if __name__ == '__main__':
    port = int(os.environ.get("PORT", 5003))
    app.run(debug=True, host='0.0.0.0', port=port)